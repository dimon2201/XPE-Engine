#include msaa_sampling.shader

struct VSOut
{
    float4 positionClip : SV_POSITION;
    float2 uv : XPE_UV;
    float ssaoDirectionCount : XPE_SSAO_DIRECTION_COUNT;
    float ssaoSampleCount : XPE_SSAO_SAMPLE_COUNT;
};

struct PSOut
{
    float4 color : SV_Target0;
};

Texture2DMS<float4> PositionTexture : register(t0);
Texture2DMS<float4> NormalTexture : register(t1);
Texture2DMS<float> DepthTexture : register(t2);

PSOut ps_main(VSOut psIn)
{
    uint width = 0;
    uint height = 0;
    uint sampleCount = 0;
    DepthTexture.GetDimensions(width, height, sampleCount);

    int2 sampleDirections[4] =
    {
        int2(-1, -1),
        int2(-1, 1),
        int2(1, -1),
        int2(1, 1)
    };

    float occlusion = 0.0;
    int2 curCoord = int2(psIn.uv * float2(width, height));
    float curDepth = SampleMSAATexture(DepthTexture, float2(curCoord));
    float3 curPos = SampleMSAATexture(PositionTexture, float2(curCoord));
    float3 curNormal = SampleMSAATexture(NormalTexture, float2(curCoord));
    for (int dir = 0; dir < int(4); dir++)
    {
        for (int s = 0; s < int(4); s++)
        {
            int2 sampleCoord = int2(curCoord + (sampleDirections[dir] * 2 * (s + 1)));
            float3 samplePos = PositionTexture.Load(int3(sampleCoord, 0));
            float3 curToSample = samplePos - curPos;
            if (length(curToSample) < 1.0) {
                occlusion += max(0.0, pow(dot(curNormal, normalize(curToSample)), 3.0));
            }
        }
    }
    occlusion /= int(4) * int(4);
    occlusion = 1.0 - occlusion;

    PSOut psOut;
    psOut.color = float4(occlusion, occlusion, occlusion, 1.0);

    return psOut;
}