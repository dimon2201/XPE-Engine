struct VSOut
{
    float4 positionClip : SV_POSITION;
    float2 uv : XPE_UV;
    float ssaoDirectionCount : XPE_SSAO_DIRECTION_COUNT;
    float ssaoSampleCount : XPE_SSAO_SAMPLE_COUNT;
};

struct PSOut
{
    float4 color : SV_Target0;
};

Texture2D<float4> PositionTexture : register(t0);
Texture2D<float4> NormalTexture : register(t1);
Texture2D<float> DepthTexture : register(t2);

PSOut ps_main(VSOut psIn)
{
    uint width = 0;
    uint height = 0;
    DepthTexture.GetDimensions(width, height);

    int2 sampleDirections[4] =
    {
        int2(-1, -1),
        int2(-1, 1),
        int2(1, -1),
        int2(1, 1)
    };

    #define DIRS_COUNT 4
    #define SAMPLE_COUNT 4
    float occlusion = 0.0;
    int2 curCoord = int2(psIn.uv * float2(width, height));
    float curDepth = DepthTexture.Load(int3(curCoord, 0));
    float3 curPos = PositionTexture.Load(int3(curCoord, 0)).xyz;
    float3 curNormal = NormalTexture.Load(int3(curCoord, 0)).xyz;
    for (int dir = 0; dir < int(psIn.ssaoDirectionCount); dir++)
    {
        for (int s = 0; s < int(psIn.ssaoSampleCount); s++)
        {
            int2 sampleCoord = int2(curCoord + (sampleDirections[dir] * 2 * (s + 1)));
            float3 samplePos = PositionTexture.Load(int3(sampleCoord, 0));
            float3 curToSample = samplePos - curPos;
            if (length(curToSample) < 1.0) {
                occlusion += max(0.0, pow(dot(curNormal, normalize(curToSample)), 3.0));
            }
        }
    }
    occlusion /= int(psIn.ssaoDirectionCount) * int(psIn.ssaoSampleCount);
    occlusion = 1.0 - occlusion;

    PSOut psOut;
    psOut.color = float4(1.0, 1.0, 1.0, 1.0);

    return psOut;
}